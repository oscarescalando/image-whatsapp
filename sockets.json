{
  "1": {
    "logout": "async (msg) => {\n        var _a;\n        const jid = (_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id;\n        if (jid) {\n            await sendNode({\n                tag: 'iq',\n                attrs: {\n                    to: WABinary_1.S_WHATSAPP_NET,\n                    type: 'set',\n                    id: generateMessageTag(),\n                    xmlns: 'md'\n                },\n                content: [\n                    {\n                        tag: 'remove-companion-device',\n                        attrs: {\n                            jid,\n                            reason: 'user_initiated'\n                        }\n                    }\n                ]\n            });\n        }\n        end(new boom_1.Boom(msg || 'Intentional Logout', { statusCode: Types_1.DisconnectReason.loggedOut }));\n    }",
    "sendMessage": "async (jid, content, options = {}) => {\n            var _a, _b, _c;\n            const userJid = authState.creds.me.id;\n            if (typeof content === 'object' &&\n                'disappearingMessagesInChat' in content &&\n                typeof content['disappearingMessagesInChat'] !== 'undefined' &&\n                (0, WABinary_1.isJidGroup)(jid)) {\n                const { disappearingMessagesInChat } = content;\n                const value = typeof disappearingMessagesInChat === 'boolean' ?\n                    (disappearingMessagesInChat ? Defaults_1.WA_DEFAULT_EPHEMERAL : 0) :\n                    disappearingMessagesInChat;\n                await groupToggleEphemeral(jid, value);\n            }\n            else {\n                const fullMsg = await (0, Utils_1.generateWAMessage)(jid, content, {\n                    logger,\n                    userJid,\n                    getUrlInfo: text => (0, link_preview_1.getUrlInfo)(text, {\n                        thumbnailWidth: linkPreviewImageThumbnailWidth,\n                        fetchOpts: {\n                            timeout: 3000,\n                            ...axiosOptions || {}\n                        },\n                        logger,\n                        uploadImage: generateHighQualityLinkPreview\n                            ? waUploadToServer\n                            : undefined\n                    }),\n                    //TODO: CACHE\n                    getProfilePicUrl: sock.profilePictureUrl,\n                    upload: waUploadToServer,\n                    mediaCache: config.mediaCache,\n                    options: config.options,\n                    messageId: (0, Utils_1.generateMessageIDV2)((_a = sock.user) === null || _a === void 0 ? void 0 : _a.id),\n                    ...options,\n                });\n                const isDeleteMsg = 'delete' in content && !!content.delete;\n                const isEditMsg = 'edit' in content && !!content.edit;\n                const isPinMsg = 'pin' in content && !!content.pin;\n                const additionalAttributes = {};\n                // required for delete\n                if (isDeleteMsg) {\n                    // if the chat is a group, and I am not the author, then delete the message as an admin\n                    if ((0, WABinary_1.isJidGroup)((_b = content.delete) === null || _b === void 0 ? void 0 : _b.remoteJid) && !((_c = content.delete) === null || _c === void 0 ? void 0 : _c.fromMe)) {\n                        additionalAttributes.edit = '8';\n                    }\n                    else {\n                        additionalAttributes.edit = '7';\n                    }\n                }\n                else if (isEditMsg) {\n                    additionalAttributes.edit = '1';\n                }\n                else if (isPinMsg) {\n                    additionalAttributes.edit = '2';\n                }\n                if ('cachedGroupMetadata' in options) {\n                    console.warn('cachedGroupMetadata in sendMessage are deprecated, now cachedGroupMetadata is part of the socket config.');\n                }\n                await relayMessage(jid, fullMsg.message, { messageId: fullMsg.key.id, useCachedGroupMetadata: options.useCachedGroupMetadata, additionalAttributes, statusJidList: options.statusJidList });\n                if (config.emitOwnEvents) {\n                    process.nextTick(() => {\n                        processingMutex.mutex(() => (upsertMessage(fullMsg, 'append')));\n                    });\n                }\n                return fullMsg;\n            }\n        }"
  }
}